"use strict";(self.webpackChunkswiftui_realm_app=self.webpackChunkswiftui_realm_app||[]).push([[649],{4137:(e,n,r)=>{r.d(n,{Zo:()=>p,kt:()=>w});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=t.createContext({}),l=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},p=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(r),m=a,w=d["".concat(c,".").concat(m)]||d[m]||u[m]||o;return r?t.createElement(w,i(i({ref:n},p),{},{components:r})):t.createElement(w,i({ref:n},p))}));function w(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=m;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},3353:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var t=r(7462),a=(r(7294),r(4137));r(9524);const o={},i="OpenSyncedRealmView",s={unversionedId:"ios-app-changes/open-synced-realm-view",id:"ios-app-changes/open-synced-realm-view",title:"OpenSyncedRealmView",description:"This wiew will check how our connection to MongoDB Atlas progress and will inform us if there's any error. Once is connected with a Synced Realm (in case .open(let realm)) it shows our old friend MainView. As we're adding to the environment this new, synced Realm our app will keep working as before, storing everything locally AND syncing to our MongoDB Database.",source:"@site/docs/3--ios-app-changes/6-open-synced-realm-view.mdx",sourceDirName:"3--ios-app-changes",slug:"/ios-app-changes/open-synced-realm-view",permalink:"/swiftui-atlas-sync-app-lab/docs/ios-app-changes/open-synced-realm-view",draft:!1,editUrl:"https://github.com/mongodb-developer/swiftui-atlas-sync-app-lab/blob/main/docs/3--ios-app-changes/6-open-synced-realm-view.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Adding the Flexible Sync Configuration",permalink:"/swiftui-atlas-sync-app-lab/docs/ios-app-changes/adding-config-realm"},next:{title:"Adding ownerId",permalink:"/swiftui-atlas-sync-app-lab/docs/ios-app-changes/adding-owner-id"}},c={},l=[],p={toc:l},d="wrapper";function u(e){let{components:n,...r}=e;return(0,a.kt)(d,(0,t.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"opensyncedrealmview"},"OpenSyncedRealmView"),(0,a.kt)("p",null,"This wiew will check how our connection to MongoDB Atlas progress and will inform us if there's any error. Once is connected with a Synced Realm (in ",(0,a.kt)("inlineCode",{parentName:"p"},"case .open(let realm)"),") it shows our old friend ",(0,a.kt)("inlineCode",{parentName:"p"},"MainView"),". As we're adding to the ",(0,a.kt)("inlineCode",{parentName:"p"},"environment")," this new, synced Realm our app will keep working as before, storing everything locally AND syncing to our MongoDB Database."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},"import SwiftUI\nimport RealmSwift\n\n/// This view opens a synced realm.\nstruct OpenSyncedRealmView: View {\n    @ObservedObject var app: RealmSwift.App\n\n    // We've injected a `flexibleSyncConfiguration` as an environment value,\n    // so `@AsyncOpen` here opens a realm using that configuration.\n    @AsyncOpen(appId: nil, timeout: 4000) var asyncOpen\n    \n    var body: some View {\n        // Because we are setting the `ownerId` to the `user.id`, we need\n        // access to the app's current user in this view.\n        let user = app.currentUser\n        switch asyncOpen {\n        // Starting the Realm.asyncOpen process.\n        // Show a progress view.\n        case .connecting:\n            ProgressView()\n        // Waiting for a user to be logged in before executing\n        // Realm.asyncOpen.\n        case .waitingForUser:\n            ProgressView(\"Waiting for user to log in...\")\n        // The realm has been opened and is ready for use.\n        // Show the content view.\n        case .open(let realm):\n            MainView()\n            .environment(\\.realm, realm)\n        // The realm is currently being downloaded from the server.\n        // Show a progress view.\n        case .progress(let progress):\n            ProgressView(progress)\n        // Opening the Realm failed.\n        // Show an error view.\n        case .error(let error):\n            Text(error.localizedDescription)\n                .font(.callout)\n                .multilineTextAlignment(.center)\n                .padding(.bottom, 40).padding()\n        }\n    }\n}\n")))}u.isMDXComponent=!0}}]);